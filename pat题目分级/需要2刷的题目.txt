25,30分题目
图：
1018 ok
1072 ok		ok 但是时间太长了
1087  $ ok 注意map[a]=0,如果索引就是0开始,有冲突,最好用map.find			dijkstra中两个vis千万别忘
1076  $ ok
1111  $ ok
1139
1146		拓扑排序

图论:
1122  
1126
1150
1154
1155

树：
1053  $   ok
1064  $   ok 		CBT构建,使用中序为排好序的特点
1099  	  ok		BST构建,使用中序
1119  	  ok		先序转后序,外面 int k 后，在for里面又int k了。
1123  	  不ok		平衡二叉树建立
1127  $   ok		建树,用中序和后序建树
1135      ok		判断红黑树
1143 $	  ok		LCA
1147 $				堆
1151 				LCA 
1155  				堆		和最短路径一样，打印时用path那个模板把
1066 $				平衡二叉树构建
1110 $				判断完全二叉树
1115 $				计算二叉树层的节点
1138 				由中序先序直接得到后序第一个节点(同先序后序建树一样,不过用个剪枝,放的位置和树先中后序类似)
1130 				中缀表达式


栈,队列,链表:
1051: 栈			ok		判断一个序列是否是栈的出栈顺序
1052: 链表  ok		ok		数据和next分离,注意空链和多余节点	
1056:队列			ok		老鼠排名次，注意，排名次一定要注意并列排名是否占下一名名额
1074:链表			ok		反转链表，妈的读题看题目要求啊
1097:链表  $		ok		重组链表
1133:链表			ok		删除链表一些节点


其他：
1057：树状数组
1107：并查集  $
1114：并查集  ok
1118：并查集  $
1067：贪心  $ 
1089,1098：判断排序方法
1105：打印螺旋矩阵
1059:大数素数分解
1145: hash
1153：排序

1. 对于中序，后序先序等互相获得的题目,递归条件可以改成通用
if(preL>preR)return;
else if(preL == preR){
   post.push_back(pre[preL]);
   return;
}

2. 对于AVL树,注意：左旋右旋一定要写对，如果结果不对很可能是因为左旋右旋
插入函数中,插入结点后对树进行调整时 要记得将旋后的返回值赋值给s,如: s = rightRotate(s)

3. 对于图的BFS算法
如果使用结点记录层数，在遍历时next.level = top.level+1;放在 if(!vis[next.u])外面,因为每次都是使用新的
结点，所以不会覆盖，如果使用一个数组记录，则要放在判断里面，不然会被覆盖

4. 除了只涉及完全二叉树和图，一定要建结点，不要浪费时间，有时候用到子树T[T[s].l]一定要先检查是否为-1

5.对于大根堆,小根堆的判断中,从[2,n]开始遍历,将每个i作为叶结点写for循环要比递归方便
方便的方法:
for(int i = 2;i <= n;i++){
    if(HEAP[i/2].key>HEAP[i].key)issmall=false;
    if(HEAP[i/2].key<HEAP[i].key)isbig=false;
}

6. 对于图的最小路径题，最重要是要看清题目要求，先列出来判断的1，2，3要求再写

7. 链表题目全部拆开，拆开大法好,但是要注意长度为0的情况

8.对于图论题目,判断是否成环可以比较set元素个数和读入结点个数是否相等来判断

9.对于并查集的题目，在统计时要使用findFa(x)来查找father，因为father[x]里面存的可能不是祖先而是直系父亲

10.对于数1-n中有多少个 num(1<= num <=9 )的题目，对第i位进行分离即可,即ai = num,ai<num,ai>num;分别得出左右数的大小，然后乘在一起等操作即可。

11. 对于最长不下降子序列或者最长不上升子序列,剔除题目给的不用数据

12.最长回文串先遍历长度,在遍历右端点,通过长度和右端点来计算左端点