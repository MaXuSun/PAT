1002 模拟多项式加
1003 图					ok(最短路径+点权+最短路径数量)
1006 查找元素 
1007 DP					ok(最大连续子序列)					可二刷
1009 (时间)
1010 二分法				ok(基数数字转换)				这里如果不使用二分法,只有一个测试点过不去
1012 排序				ok(结构体排序)					亮点在,对四门课同样的排序可以只写一个cmp,结构体中用数组即可
1013 图					ok(无向图的连通分量)
1016 排序
1017 模拟银行
1020 二叉树查找树
1021 图					ok(无向图+连通分量+最深结点*2)
1024 大整数
1025 排序
1028 排序
1029 two pointers
1032 链表
1033 贪心
1036 查找元素
1037 贪心
1039 STL应用
1040 DP
1043 二叉查找树
1044 二分查找
1047 STL应用
1048 散列
1051 栈					ok(判断序列是否为出栈序列)	二刷		这里可用这种最笨的方法来输出所有栈的结果
1052 链表				ok(模拟静态链表,有点坑)		二刷,里面有很多好的写法
1055 排序				ok(结构体排序)				有点水
1056 队列				ok(题目不是多难,就是开始想岔了,没读懂题目)		可二刷
1059 素数表建立			ok(大数的素数分解)			二刷		这题变形可出关于正整数的因子个数
1060 科学计数法
1062 排序				ok(排序,cmp+sort)					
1063 set,STL应用		ok(set应用)
1066 avi				ok(AVI的建立)				可二刷,这次使用的是静态链表方法
1067 贪心				ok(贪心+排序)				挺绕的一题，可以二刷
1070 贪心				ok(贪心)					有一个测试用例没过,然后发现因为float的数据被我认为是int了
1071 map,STL			ok(字符串处理)				这里使用两个字符串统计单词，要比之前我只用索引来确定方便很多
1074 链表				ok(静态链表反转)							二刷,数据和地址分离，直接反转地址，太特么秀了
1078 hash				ok(Hash二次探测法)							
1079 树					ok(树+找叶结点+深度)
1082 字符串处理			不ok(数字的中国传统读法)
1083 排序				ok(排序)			水题
1085 二分法
1086 树					ok(先序中序转后序)
1089 判断排序方法       ok						二刷
1090 树					ok(树+找叶结点+深度)
1093 逻辑题
1094 树					ok(树+最多结点层数)
1097 链表				ok(链表分割)			可二刷				仍然是用那种无赖的方法，很爽
1098 判断排序方法	    ok(堆排序+插入排序)		与1089一起二刷
1101 快排				ok(快排特点)			
1102 树					ok(树+层序+中序)	indices:指数
1105 模拟				ok(打印螺旋形矩阵)							二刷
1106 树					ok(树+DFS+叶子最小的层)						可以二刷
1109 逻辑题				不ok(拍照站位)			不知道为啥错
1110 完全二叉树			ok(判断一个树是不是完全二叉树)				可二刷
1113 排序+贪心			ok(贪心)									有点水
1115 二叉查找树 		ok(二叉查找树+静态构建)						二刷(必须)
1114 并查集				ok(并查集统计很多)							二刷
1117 逻辑题				ok(读懂题意就较为简单)
1118 并查集				ok(并查集统计集合和元素个数) 				二刷
1121 set应用			ok(hash用法)
1122 图					ok(哈密顿环)								可以再做,被自己写复杂了
1125 贪心				ok(贪心,排序)								题目不难，就是浮点数向整数舍入有点恶心
1126 图					ok(欧拉图)		这里需要判断图是否连通
1129 set应用，运算符重载
1130 树					ok(表达式树+中序)
1133 链表				ok(模拟链表处理)							链表处理不能忘了去不用的结点,并且有种非常无赖的方法
1134 hash				ok(hash_set)								这题如果使用set,则200多毫秒，如果使用hash_set则快些
1137 map映射,排序		ok(float转int)			四舍五入:round	向上取整:ceil	向下取整:floor,强转
1138 树					ok(二叉树先序+中序转后序)					可二刷		这里需要剪枝,另外这种代码可以不建树，直接由建树代码改造
1141 map,排序			ok(map,STL的应用)		这里有个坑：浮点转整形时，计算sum时，将sum全计算完再做，若每次都转再相加，精度严重丢失							case insensitive:不区分大小写
1142 图					ok(找完全图)
1145 哈希				ok(Hash二次探测法+查找)						二刷
1146 图					ok(topo排序)								可以再做,被自己写复杂了
1149 STL应用			ok(set应用)								水题
1150 图					ok(旅行商问题+哈密顿变体)
1153 排序,模拟			ok(排序)									二刷,答案的结构体设置特别好
1154 hash 图			ok(图+边两端结点颜色不同)					注意如何存储一个一个的边


题目中的浮点数舍入整数：
1. 每加一次都舍入一次(向下，向上，四舍五入)
2. 最后一次再舍入(向下，向上，四舍五入)

hash_set用法：加上下面两句
#include <hash_set>
using namespace __gnu_cxx;

2.层序中序构建二叉树要学习

3. 二叉树构建需要中序+(层序,先序,后序)，二叉查找树只需要中序即可

4. 链表题，一定要注意可能给用不到的结点
有个非常好用但是无赖的方法，将数据和下一个地址分开存储，得到的结果按照顺序存储输出答案的时候依次向下输出即可

5. hash二次探测法：从[0,size-1],每次用(key+step*step)%size 得到下标
	    对于查找： 从[0,size]开始查找
		
6. 1012亮点:
struct node{int score[4], rank[4];} bool cmp1(node a, node b){return a.score[flag] > b.score[flag];} 这里一个flag排了四个数组

7. 段错误一个原因: 返回值为int的函数,忘了写return

8.string.rbegin(),rend()是从右向左遍历